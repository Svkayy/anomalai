<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAM2 Image Segmentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;  /* Increased from 1200px to 1400px for larger images */
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            background: #f9f9f9;
        }

        .file-size-info {
            font-size: 0.9em;
            color: #666;
            margin: 10px 0;
            font-style: italic;
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
        }

        .image-container {
            display: flex;
            gap: 30px;  /* Increased from 20px to 30px for more spacing */
            margin-top: 40px;  /* Increased from 30px to 40px */
            flex-wrap: wrap;
            justify-content: center;  /* Center the sections */
            align-items: flex-start;  /* Align sections to top */
        }
        
        /* Responsive design for smaller screens */
        @media (max-width: 1200px) {
            .image-container {
                gap: 20px;  /* Reduce gap on smaller screens */
            }
            
            .image-section {
                min-width: 400px;  /* Slightly smaller on medium screens */
            }
        }
        
        @media (max-width: 768px) {
            .image-container {
                flex-direction: column;  /* Stack vertically on mobile */
                gap: 15px;
            }
            
            .image-section {
                min-width: 100%;  /* Full width on mobile */
                padding: 20px;  /* Reduce padding on mobile */
            }
        }

        .image-section {
            flex: 1;
            min-width: 450px;  /* Increased from 300px to 450px for larger sections */
            background: #f9f9f9;
            border-radius: 12px;  /* Increased from 10px to 12px */
            padding: 30px;  /* Increased from 20px to 30px for more padding */
            text-align: center;
        }

        .image-section h3 {
            margin-bottom: 20px;  /* Increased from 15px to 20px */
            color: #333;
            font-size: 1.4em;  /* Added larger font size */
            font-weight: 600;  /* Added font weight for emphasis */
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            border: 3px solid #ddd;  /* Increased from 2px to 3px */
            border-radius: 12px;  /* Increased from 8px to 12px */
            overflow: hidden;
            margin: 15px 0;  /* Added margin for better spacing */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);  /* Added subtle shadow */
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
            border-radius: 8px;  /* Added border radius to canvas */
        }
        
        #resultCanvas {
            max-width: 100%;
            height: auto;
            display: block;
        }
        
        .result-canvas-container {
            position: relative;
            display: inline-block;
            border: 3px solid #ddd;  /* Increased from 2px to 3px */
            border-radius: 12px;  /* Increased from 8px to 12px */
            overflow: visible;
            margin: 15px 0;  /* Increased from 10px to 15px */
            background: #f8f9fa;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);  /* Added subtle shadow */
        }
        
        .label-overlay {
            position: absolute;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 11px;
            font-weight: 600;
            color: #555;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(3px);
            white-space: nowrap;
            max-width: 120px;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .label-overlay:hover {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }
        

        .controls {
            margin-top: 20px;
            padding: 20px;
            background: #f0f4ff;
            border-radius: 10px;
        }

        /* Video Controls Styles */
        .video-controls {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #dee2e6;
        }

        .video-info {
            margin-bottom: 15px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .frame-slider-container {
            margin: 20px 0;
        }

        .frame-slider-wrapper {
            position: relative;
            margin-bottom: 10px;
        }

        .frame-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .frame-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .frame-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.85em;
            color: #666;
        }

        .frame-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .frame-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        .frame-btn:hover {
            background: #0056b3;
        }

        .frame-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .frame-timestamp {
            text-align: center;
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }


        .control-group {
            margin-bottom: 15px;
        }

        /* Hover effects for mask labels */
        .mask-label {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .mask-label:hover {
            transform: scale(1.2);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .btn {
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .instructions {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .instructions h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }
        
        .text-result {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #dee2e6;
        }
        
        .text-result h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .text-content {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ced4da;
        }
        
        .text-info {
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .confidence, .word-count, .total-words, .threshold {
            margin-right: 20px;
            padding: 4px 8px;
            background: #e9ecef;
            border-radius: 4px;
        }
        
        .text-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        
        .annotated-image-container {
            margin: 15px 0;
            text-align: center;
        }
        
        .annotated-image-container h4 {
            margin-bottom: 10px;
            color: #495057;
        }
        
        .font-analysis-container {
            margin: 15px 0;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
        }
        
        .font-analysis-container h4 {
            margin-bottom: 15px;
            color: #495057;
        }
        
        .font-item {
            background: white;
            border: 1px solid #ced4da;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }
        
        .font-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .font-count {
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }
        
        .font-details {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .font-sizes, .font-samples {
            background: #e9ecef;
            padding: 3px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .letter-masks-container {
            margin: 15px 0;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
        }
        
        .letter-masks-container h4 {
            margin-bottom: 15px;
            color: #495057;
        }
        
        .letter-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .letter-controls .btn {
            margin: 0;
        }
        
        .btn-active {
            background-color: #28a745 !important;
            color: white !important;
        }
        
        .letter-image-container {
            margin: 15px 0;
            text-align: center;
        }
        
        .letter-stats {
            text-align: center;
            margin-top: 10px;
        }
        
        .letter-count {
            background: #17a2b8;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        /* Coordinate Window Styles */
        .coordinate-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            max-height: 80vh;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            overflow: hidden;
        }
        
        .coordinate-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .coordinate-header h3 {
            margin: 0;
            font-size: 1.2em;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .close-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .coordinate-content {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .coordinate-info {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .coordinate-list {
            margin-bottom: 20px;
        }
        
        .coordinate-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        
        .coordinate-item:hover {
            background: #e9ecef;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .coordinate-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .coordinate-label {
            font-weight: 600;
            color: #495057;
            font-size: 1.1em;
        }
        
        .coordinate-confidence {
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }
        
        .coordinate-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .coordinate-detail {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        
        .coordinate-detail-label {
            color: #6c757d;
            font-weight: 500;
        }
        
        .coordinate-detail-value {
            color: #495057;
            font-family: monospace;
        }
        
        /* Depth color coding */
        .depth-value {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .depth-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        
        .coordinate-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .coordinate-actions .btn {
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎨 SAM2 Image Segmentation</h1>
            <p>Upload an image and select points or draw a bounding box to segment objects</p>
        </div>

        <div class="content">
            <div class="upload-section" id="uploadSection">
                <h3>📁 Upload Image or Video</h3>
                <p>Drag and drop an image or video here or click to browse</p>
                <p class="file-size-info">Maximum file size: 500MB (videos will be processed to extract frames)</p>
                <input type="file" id="fileInput" class="file-input" accept="image/*,video/*">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Choose File
                </button>
            </div>


            <!-- Video Controls Section -->
            <div class="video-controls" id="videoControls" style="display: none;">
                <h3>🎬 Video Frame Analysis</h3>
                <div class="video-info" id="videoInfo"></div>
                <div class="frame-slider-container">
                    <div class="frame-slider-wrapper">
                        <input type="range" id="frameSlider" min="0" max="0" value="0" class="frame-slider">
                        <div class="slider-labels">
                            <span id="currentFrameLabel">Frame 0</span>
                            <span id="totalFramesLabel">of 0</span>
                        </div>
                    </div>
                    <div class="frame-controls">
                        <button id="prevFrameBtn" class="frame-btn">⏮</button>
                        <button id="playPauseBtn" class="frame-btn">▶️</button>
                        <button id="nextFrameBtn" class="frame-btn">⏭</button>
                    </div>
                </div>
                <div class="frame-timestamp" id="frameTimestamp">00:00</div>
            </div>

            <div class="instructions" id="instructions" style="display: none;">
                <h4>📋 Instructions</h4>
                <div id="pointInstructions" style="display: none;">
                    <ul>
                        <li><strong>Left click:</strong> Add foreground point (green)</li>
                        <li><strong>Right click:</strong> Add background point (red)</li>
                        <li><strong>Add as many points as needed</strong> for precise segmentation</li>
                        <li><strong>Result:</strong> Shows original image with blue overlay on segmented area</li>
                    </ul>
                </div>
                <div id="bboxInstructions" style="display: none;">
                    <ul>
                        <li><strong>Click and drag:</strong> Draw a bounding box</li>
                        <li><strong>Release:</strong> Confirm the selection</li>
                        <li><strong>Result:</strong> Shows original image with blue overlay on segmented area within the box</li>
                    </ul>
                </div>
                <div id="gridInstructions" style="display: none;">
                    <ul>
                        <li><strong>Click "Grid Segmentation":</strong> Automatically generates 32 target points (reduced from 256 for cleaner results)</li>
                        <li><strong>Process:</strong> Segments up to 15 unique objects found in the image (reduced from 50 for less over-segmentation)</li>
                        <li><strong>Result:</strong> Shows each object with a different colored overlay and cleaner object boundaries</li>
                        <li><strong>✨ Optimization:</strong> Reduced grid points and max masks for better performance and cleaner segmentation</li>
                    </ul>
                </div>
            </div>

            <div class="image-container" id="imageContainer" style="display: none;">
                <div class="image-section">
                    <h3>Original Image</h3>
                    <div class="canvas-container">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                </div>
                <div class="image-section">
                    <h3>Segmented Result</h3>
                    <div class="result-canvas-container" id="resultContainer">
                        <canvas id="resultCanvas"></canvas>
                    </div>
                </div>
                <div class="image-section">
                    <h3>Depth Map</h3>
                    <div class="canvas-container">
                        <canvas id="depthCanvas"></canvas>
                    </div>
                </div>
            </div>

            <!-- Coordinate Dictionary Window -->
            <div class="coordinate-window" id="coordinateWindow" style="display: none;">
                <div class="coordinate-header">
                    <h3>📍 Object Coordinates & Depth</h3>
                    <button class="close-btn" onclick="closeCoordinateWindow()">×</button>
                </div>
                <div class="coordinate-content">
                    <div class="coordinate-info">
                        <p><strong>Coordinates are relative to image size (0-1)</strong></p>
                        <p><strong>Depth values are normalized (0-1)</strong></p>
                        <p><strong>Depth colors match the depth map visualization</strong></p>
                    </div>
                    <div class="coordinate-list" id="coordinateList">
                        <!-- Coordinates will be populated here -->
                    </div>
                    <div class="coordinate-actions">
                        <button class="btn btn-secondary" onclick="copyCoordinates()">📋 Copy JSON</button>
                        <button class="btn btn-info" onclick="exportCoordinates()">💾 Export CSV</button>
                    </div>
                </div>
            </div>

            <div class="controls" id="controls" style="display: none;">
                <div class="control-group">
                    <label>Selection Method:</label>
                    <button class="btn" id="pointBtn" onclick="setSelectionMode('points')">Point Selection</button>
                    <button class="btn" id="bboxBtn" onclick="setSelectionMode('bbox')">Bounding Box</button>
                    <button class="btn" id="gridBtn" onclick="setSelectionMode('grid')">Grid Segmentation</button>
                </div>
                <div class="control-group">
                    <button class="btn btn-success" id="segmentBtn" onclick="processSelection()" disabled>
                        🎯 Process Selection
                    </button>
                    <button class="btn btn-secondary" onclick="clearSelection()">Clear Selection</button>
                    <button class="btn btn-secondary" onclick="resetApp()">Reset</button>
                </div>
                <div class="control-group" id="downloadSection" style="display: none;">
                    <button class="btn btn-primary" id="downloadBtn" onclick="downloadPSDs()">
                        📁 Download PSD Files
                    </button>
                    <small class="text-muted">Download individual PNG files for each segmented object</small>
                </div>
                <div class="control-group" id="coordinateSection" style="display: none;">
                    <button class="btn btn-success" id="coordinateBtn" onclick="showCoordinateWindow()">
                        📍 Show Object Coordinates
                    </button>
                    <small class="text-muted">View relative coordinates and depth for each segmented object</small>
                </div>
                <div class="control-group">
                    <button class="btn btn-info" id="extractTextBtn" onclick="extractText()" disabled>
                        📝 Extract Text
                    </button>
                    <small class="text-muted">Extract text from the uploaded image using OCR</small>
                    <div class="control-group">
                        <button class="btn btn-warning" id="depthBtn" onclick="generateDepth()" disabled>
                            🌄 Get Depth Map
                        </button>
                        <small class="text-muted">Generate a depth map using Depth Anything</small>
                    </div>
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Processing image segmentation...</p>
            </div>
            
            <div class="text-result" id="textResult" style="display: none;">
                <h3>📝 Extracted Text</h3>
                                <div class="text-content">
                    <div class="text-info">
                        <span class="confidence" id="confidence"></span>
                        <span class="word-count" id="wordCount"></span>
                        <span class="total-words" id="totalWords"></span>
                        <span class="threshold" id="threshold"></span>
                    </div>
                    <div class="annotated-image-container" id="annotatedImageContainer" style="display: none;">
                        <h4>📸 Annotated Image with High-Confidence Words</h4>
                        <img id="annotatedImage" alt="Image with text bounding boxes" style="max-width: 100%; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    <div class="font-analysis-container" id="fontAnalysisContainer" style="display: none;">
                        <h4>🔤 Font Analysis</h4>
                        <div id="fontAnalysisContent"></div>
                    </div>
                    <div class="letter-masks-container" id="letterMasksContainer" style="display: none;">
                        <h4>🔤 Letter Masks & Removal</h4>
                        <div class="letter-controls">
                            <button class="btn btn-primary" onclick="toggleLetterView('mask')">📋 Show Letter Masks</button>
                            <button class="btn btn-success" onclick="toggleLetterView('removed')">🚫 Show Letter-Removed</button>
                            <button class="btn btn-info" onclick="toggleLetterView('original')">🖼️ Show Original</button>
                        </div>
                        <div class="letter-image-container">
                            <img id="letterImage" alt="Letter processing result" style="max-width: 100%; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        <div class="letter-stats">
                            <span class="letter-count" id="letterCount"></span>
                        </div>
                    </div>
                    <div class="text-display" id="textDisplay"></div>
                    <button class="btn btn-secondary" onclick="copyText()">📋 Copy Text</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentImage = null;
        let currentFileId = null;
        let selectionMode = 'points';
        let points = [];
        let bbox = null;
        let isDrawing = false;
        
        // Video-related variables
        let currentVideo = null;
        let currentVideoId = null;
        let videoFrames = [];
        let videoMetadata = null;
        let currentFrameNumber = 0;
        let isPlaying = false;
        let playInterval = null;
        let startPoint = null;

        // Canvas elements
        const originalCanvas = document.getElementById('originalCanvas');
        const resultCanvas = document.getElementById('resultCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const resultCtx = resultCanvas.getContext('2d');

        // File upload handling
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        
        // Drag and drop
        const uploadSection = document.getElementById('uploadSection');
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });
        
        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });
        
        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            if (!file.type.startsWith('image/') && !file.type.startsWith('video/')) {
                showError('Please select a valid image or video file.');
                return;
            }

            if (file.type.startsWith('image/')) {
                handleImageFile(file);
            } else if (file.type.startsWith('video/')) {
                handleVideoFile(file);
            }
        }

        function handleImageFile(file) {
            const formData = new FormData();
            formData.append('image', file);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentFileId = data.file_id;
                    loadImage(file);
                    // Enable extract text button
                    document.getElementById('extractTextBtn').disabled = false;
                    document.getElementById('depthBtn').disabled = false;
                } else {
                    showError(data.error || 'Upload failed');
                }
            })
            .catch(error => {
                showError('Upload failed: ' + error.message);
            });
        }

        function handleVideoFile(file) {
            // Check file size before upload
            const maxSize = 500 * 1024 * 1024; // 500MB
            if (file.size > maxSize) {
                showError(`Video file too large: ${(file.size / (1024*1024)).toFixed(1)}MB. Maximum allowed: 500MB. Please compress your video or use a smaller file.`);
                return;
            }

            const formData = new FormData();
            formData.append('video', file);

            showLoading(true);

            fetch('/upload_video', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.status === 413) {
                    return response.json().then(data => {
                        throw new Error(data.error || 'File too large');
                    });
                }
                return response.json();
            })
            .then(data => {
                showLoading(false);
                if (data.success) {
                    currentVideoId = data.video_id;
                    videoFrames = data.frames;
                    videoMetadata = data.metadata;
                    currentFrameNumber = 0;
                    
                    // Show video controls
                    showVideoControls();
                    
                    // Enable depth button for video
                    document.getElementById('depthBtn').disabled = false;
                    
                    // Load first frame
                    loadVideoFrame(0);
                    
                    // Show file size info
                    if (data.file_size_mb) {
                        console.log(`Video uploaded successfully: ${data.file_size_mb}MB`);
                    }
                } else {
                    showError(data.error);
                }
            })
            .catch(error => {
                showLoading(false);
                console.error('Error:', error);
                showError(error.message || 'Video upload failed');
            });
        }

        function updateImageContainerTitle(title) {
            const imageContainer = document.getElementById('imageContainer');
            const titleElement = imageContainer.querySelector('h3');
            if (titleElement) {
                titleElement.textContent = title;
            }
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    setupCanvas(img);
                    showImageContainer();
                    showInstructions();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            // Set canvas size - Higher resolution for better user experience
            const maxWidth = 1200;  // Increased from 800 to 1200 for better detail
            const maxHeight = 900;  // Increased from 600 to 900 for better detail
            let { width, height } = calculateAspectRatioFit(img.width, img.height, maxWidth, maxHeight);
            
            originalCanvas.width = width;
            originalCanvas.height = height;
            
            // Make result canvas even bigger for high-quality output
            const resultMaxWidth = 3200; // Increased from 2400 to 3200 for ultra-high resolution
            const resultMaxHeight = 2400;  // Increased from 1800 to 2400 for ultra-high resolution
            let { width: resultWidth, height: resultHeight } = calculateAspectRatioFit(img.width, img.height, resultMaxWidth, resultMaxHeight);
            
            resultCanvas.width = resultWidth;
            resultCanvas.height = resultHeight;

            // Draw original image
            originalCtx.drawImage(img, 0, 0, width, height);
            
            // Clear result canvas
            resultCtx.clearRect(0, 0, width, height);

            // Add event listeners
            setupEventListeners();
        }

        function calculateAspectRatioFit(srcWidth, srcHeight, maxWidth, maxHeight) {
            const ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
            return {
                width: srcWidth * ratio,
                height: srcHeight * ratio
            };
        }

        function setupEventListeners() {
            originalCanvas.removeEventListener('click', handlePointClick);
            originalCanvas.removeEventListener('contextmenu', handlePointClick);
            originalCanvas.removeEventListener('mousedown', handleBboxStart);
            originalCanvas.removeEventListener('mousemove', handleBboxMove);
            originalCanvas.removeEventListener('mouseup', handleBboxEnd);

            if (selectionMode === 'points') {
                originalCanvas.addEventListener('click', handlePointClick);
                originalCanvas.addEventListener('contextmenu', handlePointClick);
            } else {
                originalCanvas.addEventListener('mousedown', handleBboxStart);
                originalCanvas.addEventListener('mousemove', handleBboxMove);
                originalCanvas.addEventListener('mouseup', handleBboxEnd);
            }
        }

        function handlePointClick(e) {
            e.preventDefault();
            const rect = originalCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const label = e.button === 0 ? 1 : 0; // Left click = foreground, Right click = background

            // Allow unlimited points
            points.push({ x, y, label });
            drawPoints();
            updateSegmentButton();
        }

        function handleBboxStart(e) {
            const rect = originalCanvas.getBoundingClientRect();
            startPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            isDrawing = true;
        }

        function handleBboxMove(e) {
            if (!isDrawing) return;
            
            const rect = originalCanvas.getBoundingClientRect();
            const currentPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };

            // Redraw image and current bbox
            originalCtx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height);
            originalCtx.strokeStyle = '#00ff00';
            originalCtx.lineWidth = 2;
            originalCtx.setLineDash([5, 5]);
            originalCtx.strokeRect(
                startPoint.x, startPoint.y,
                currentPoint.x - startPoint.x,
                currentPoint.y - startPoint.y
            );
        }

        function handleBboxEnd(e) {
            if (!isDrawing) return;
            
            const rect = originalCanvas.getBoundingClientRect();
            const endPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };

            isDrawing = false;
            
            // Calculate bbox coordinates
            bbox = {
                x1: Math.min(startPoint.x, endPoint.x),
                y1: Math.min(startPoint.y, endPoint.y),
                x2: Math.max(startPoint.x, endPoint.x),
                y2: Math.max(startPoint.y, endPoint.y)
            };

            drawBbox();
            updateSegmentButton();
        }

        function drawPoints() {
            // Redraw image
            originalCtx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // Draw points
            points.forEach((point, index) => {
                originalCtx.beginPath();
                originalCtx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                originalCtx.fillStyle = point.label === 1 ? '#00ff00' : '#ff0000';
                originalCtx.fill();
                originalCtx.strokeStyle = '#000';
                originalCtx.lineWidth = 2;
                originalCtx.stroke();
                
                // Add number
                originalCtx.fillStyle = '#000';
                originalCtx.font = '12px Arial';
                originalCtx.fillText(index + 1, point.x + 8, point.y - 8);
            });
        }

        function drawBbox() {
            // Redraw image
            originalCtx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // Draw bbox
            if (bbox) {
                originalCtx.strokeStyle = '#00ff00';
                originalCtx.lineWidth = 2;
                originalCtx.setLineDash([]);
                originalCtx.strokeRect(bbox.x1, bbox.y1, bbox.x2 - bbox.x1, bbox.y2 - bbox.y1);
            }
        }

        function drawGridPoints() {
            // Redraw image
            originalCtx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // Calculate grid spacing for 32 target points (reduced from 256)
            // Using larger spacing to achieve ~32 points instead of 256
            const gridSpacing = 60; // Increased from 20 to 60 for sparser grid
            const originalWidth = currentImage.width;
            const originalHeight = currentImage.height;
            const canvasWidth = originalCanvas.width;
            const canvasHeight = originalCanvas.height;
            
            // Calculate scale factors
            const scaleX = originalWidth / canvasWidth;
            const scaleY = originalHeight / canvasHeight;
            
            // Calculate grid spacing in canvas coordinates
            const canvasGridSpacing = gridSpacing / Math.min(scaleX, scaleY);
            
            // Draw grid points
            originalCtx.fillStyle = '#ff00ff'; // Magenta color for grid points
            originalCtx.strokeStyle = '#000000';
            originalCtx.lineWidth = 1;
            
            // Span from edge to edge with dense coverage
            for (let y = 0; y < canvasHeight; y += canvasGridSpacing) {
                for (let x = 0; x < canvasWidth; x += canvasGridSpacing) {
                    // Draw circle for each grid point
                    originalCtx.beginPath();
                    originalCtx.arc(x, y, 2, 0, 2 * Math.PI); // Smaller circles for denser grid
                    originalCtx.fill();
                    originalCtx.stroke();
                }
            }
            
            // Add text to show grid info
            originalCtx.fillStyle = '#ffffff';
            originalCtx.strokeStyle = '#000000';
            originalCtx.lineWidth = 2;
            originalCtx.font = '14px Arial';
            originalCtx.textAlign = 'left';
            
            const gridCount = Math.ceil(canvasWidth / canvasGridSpacing) * Math.ceil(canvasHeight / canvasGridSpacing);
            
            originalCtx.fillText(`Grid Points: ${gridCount} (Reduced from 256 for cleaner results)`, 10, 30);
            originalCtx.strokeText(`Grid Points: ${gridCount} (Reduced from 256 for cleaner results)`, 10, 30);
        }

        function setSelectionMode(mode) {
            selectionMode = mode;
            points = [];
            bbox = null;
            
            // Update button states
            document.getElementById('pointBtn').classList.toggle('btn-success', mode === 'points');
            document.getElementById('bboxBtn').classList.toggle('btn-success', mode === 'bbox');
            document.getElementById('gridBtn').classList.toggle('btn-success', mode === 'grid');
            
            // Redraw image
            originalCtx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // If grid mode, draw grid points
            if (mode === 'grid') {
                drawGridPoints();
            }
            
            // Hide download button when switching modes
            document.getElementById('downloadSection').style.display = 'none';
            
            // Setup event listeners
            setupEventListeners();
            
            // Update instructions
            showInstructions();
            
            // Update segment button
            updateSegmentButton();
        }

        function showImageContainer() {
            document.getElementById('imageContainer').style.display = 'flex';
            document.getElementById('controls').style.display = 'block';
        }

        function showInstructions() {
            const instructions = document.getElementById('instructions');
            const pointInstructions = document.getElementById('pointInstructions');
            const bboxInstructions = document.getElementById('bboxInstructions');
            const gridInstructions = document.getElementById('gridInstructions');
            
            instructions.style.display = 'block';
            pointInstructions.style.display = selectionMode === 'points' ? 'block' : 'none';
            bboxInstructions.style.display = selectionMode === 'bbox' ? 'block' : 'none';
            gridInstructions.style.display = selectionMode === 'grid' ? 'block' : 'none';
        }

        function updateSegmentButton() {
            const segmentBtn = document.getElementById('segmentBtn');
            let canSegment = false;
            
            if (selectionMode === 'points') {
                canSegment = points.length >= 1; // At least one point required
            } else if (selectionMode === 'bbox') {
                canSegment = bbox !== null;
            } else if (selectionMode === 'grid') {
                canSegment = true; // Grid segmentation is always available
            }
            
            segmentBtn.disabled = !canSegment;
        }

        function clearSelection() {
            points = [];
            bbox = null;
            originalCtx.drawImage(currentImage, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // If in grid mode, redraw grid points
            if (selectionMode === 'grid') {
                drawGridPoints();
            }
            
            updateSegmentButton();
        }

        function resetApp() {
            currentImage = null;
            currentFileId = null;
            points = [];
            bbox = null;
            
            document.getElementById('imageContainer').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('downloadSection').style.display = 'none';
            document.getElementById('fileInput').value = '';
        }

        function processSelection() {
            if (currentVideoId && currentFileId && currentFileId.startsWith('video_')) {
                // This is a video frame, use the video frame segmentation
                segmentVideoFrame();
            } else if (currentFileId) {
                // This is a regular image
                segmentImage();
            } else {
                showError('No image or video uploaded');
            }
        }

        function extractText() {
            if (currentVideoId && currentFileId && currentFileId.startsWith('video_')) {
                // For video frames, we need to handle text extraction differently
                showError('Text extraction not available for video frames yet');
                return;
            } else if (currentFileId) {
                // Regular image text extraction
                extractTextFromImage();
            } else {
                showError('No image uploaded');
            }
        }

        function generateDepth() {
            if (!currentFileId) {
                showError('No image uploaded');
                return;
            }

            showLoading(true);

            // Auto-detect if this is a video frame or regular image
            if (currentFileId.startsWith('video_')) {
                // Video frame: use the video frame endpoint
                fetch('/depth_video_frame', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        video_id: currentVideoId,
                        frame_number: currentFrameNumber
                    })
                })
                .then(response => response.json())
                .then(data => {
                    showLoading(false);
                    if (data.success) {
                        displayDepth(data.depth_image);
                    } else {
                        showError(data.error);
                    }
                })
                .catch(error => {
                    showLoading(false);
                    console.error('Error:', error);
                    showError('Depth estimation failed');
                });
            } else {
                // Regular image: use the standard depth endpoint
                fetch(`/depth/${currentFileId}`)
                    .then(response => response.json())
                    .then(data => {
                        showLoading(false);
                        if (data.success) {
                            displayDepth(data.depth_image);
                        } else {
                            showError(data.error || 'Depth estimation failed');
                        }
                    })
                    .catch(error => {
                        showLoading(false);
                        console.error('Error:', error);
                        showError('Depth estimation failed: ' + error.message);
                    });
            }
        }

        function segmentImage() {
            if (!currentFileId) {
                showError('No image uploaded');
                return;
            }

            let prompts;
            if (selectionMode === 'points') {
                // Scale point coordinates to original image dimensions
                const originalWidth = currentImage.width;
                const originalHeight = currentImage.height;
                const canvasWidth = originalCanvas.width;
                const canvasHeight = originalCanvas.height;
                
                const scaleX = originalWidth / canvasWidth;
                const scaleY = originalHeight / canvasHeight;
                
                prompts = points.map(point => ({
                    x: point.x * scaleX,
                    y: point.y * scaleY,
                    label: point.label
                }));
            } else if (selectionMode === 'bbox') {
                // Scale bbox coordinates to original image dimensions
                const originalWidth = currentImage.width;
                const originalHeight = currentImage.height;
                const canvasWidth = originalCanvas.width;
                const canvasHeight = originalCanvas.height;
                
                const scaleX = originalWidth / canvasWidth;
                const scaleY = originalHeight / canvasHeight;
                
                // Convert to format similar to the example: [x1, y1, x2, y2]
                const scaledX1 = Math.round(bbox.x1 * scaleX);
                const scaledY1 = Math.round(bbox.y1 * scaleY);
                const scaledX2 = Math.round(bbox.x2 * scaleX);
                const scaledY2 = Math.round(bbox.y2 * scaleY);
                
                prompts = {
                    x1: scaledX1,
                    y1: scaledY1,
                    x2: scaledX2,
                    y2: scaledY2
                };
                
                // Log the scaled coordinates for debugging
                console.log('Scaled bounding box:', prompts);
            } else if (selectionMode === 'grid') {
                // For grid segmentation, no prompts needed - backend will generate grid
                prompts = {};
            } else {
                showError('No selection made');
                return;
            }

            if (!prompts) {
                showError('No selection made');
                return;
            }

            showLoading(true);

            fetch('/segment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    file_id: currentFileId,
                    prompt_type: selectionMode,
                    prompts: prompts
                })
            })
            .then(response => response.json())
            .then(data => {
                showLoading(false);
                if (data.success) {
                    // Display result (labels are already overlaid on the image)
                    if (data.labels && data.labels.length > 0) {
                        displayResultWithCoordinates(data.segmented_image, data.labels);
                    } else {
                        displayResult(data.segmented_image);
                    }
                    
                    // Log the box coordinates for debugging
                    if (data.box) {
                        console.log('Bounding box coordinates:', data.box);
                    }
                    // Log the mask count for grid segmentation
                    if (data.mask_count) {
                        console.log('Grid segmentation found', data.mask_count, 'unique objects (max 15, reduced from 50 for cleaner results)');
                        // Show download button for grid segmentation
                        showDownloadButton();
                    }
                } else {
                    showError(data.error || 'Processing failed');
                }
            })
            .catch(error => {
                showLoading(false);
                showError('Processing failed: ' + error.message);
            });
        }

        function displayResult(base64Image) {
            const img = new Image();
            img.onload = function() {
                resultCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
                resultCtx.drawImage(img, 0, 0, resultCanvas.width, resultCanvas.height);
            };
            img.src = 'data:image/png;base64,' + base64Image;
        }

        function displayResultWithCoordinates(base64Image, coordinates) {
            // Store coordinates for later use
            currentCoordinates = coordinates;
            
            // Display the image
            displayResult(base64Image);
            
            // Show coordinate button if we have coordinates
            if (coordinates && coordinates.length > 0) {
                document.getElementById('coordinateSection').style.display = 'block';
            }
        }


        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.content').insertBefore(errorDiv, document.querySelector('.upload-section'));
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        // Video control functions
        function showVideoControls() {
            document.getElementById('videoControls').style.display = 'block';
            document.getElementById('imageContainer').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            
            // Update video info
            const videoInfo = document.getElementById('videoInfo');
            videoInfo.innerHTML = `
                <strong>Video:</strong> ${videoMetadata.filename}<br>
                <strong>Duration:</strong> ${videoMetadata.duration.toFixed(2)}s<br>
                <strong>FPS:</strong> ${videoMetadata.fps.toFixed(2)}<br>
                <strong>Total Frames:</strong> ${videoMetadata.total_frames}<br>
                <strong>Extracted Frames:</strong> ${videoMetadata.extracted_frames} (every 7th frame)<br>
                <strong>Frame Interval:</strong> 7 frames
            `;
            
            // Setup slider
            const slider = document.getElementById('frameSlider');
            slider.max = videoFrames.length - 1;
            slider.value = 0;
            
            // Update labels
            updateFrameLabels();
            
            // Setup event listeners
            setupVideoEventListeners();
        }

        function setupVideoEventListeners() {
            const slider = document.getElementById('frameSlider');
            const prevBtn = document.getElementById('prevFrameBtn');
            const nextBtn = document.getElementById('nextFrameBtn');
            const playPauseBtn = document.getElementById('playPauseBtn');
            
            slider.addEventListener('input', function() {
                const frameNumber = parseInt(this.value);
                loadVideoFrame(frameNumber);
            });
            
            prevBtn.addEventListener('click', function() {
                if (currentFrameNumber > 0) {
                    loadVideoFrame(currentFrameNumber - 1);
                }
            });
            
            nextBtn.addEventListener('click', function() {
                if (currentFrameNumber < videoFrames.length - 1) {
                    loadVideoFrame(currentFrameNumber + 1);
                }
            });
            
            playPauseBtn.addEventListener('click', function() {
                togglePlayPause();
            });
        }

        function loadVideoFrame(frameNumber) {
            if (frameNumber < 0 || frameNumber >= videoFrames.length) {
                return;
            }
            
            currentFrameNumber = frameNumber;
            const frame = videoFrames[frameNumber];
            
            // Update slider
            document.getElementById('frameSlider').value = frameNumber;
            
            // Update labels
            updateFrameLabels();
            
            // Load frame image
            fetch(`/video/${currentVideoId}/frame/${frameNumber}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Display the frame in the original image section
                        const img = new Image();
                        img.onload = function() {
                            // Set as current image for all operations
                            currentImage = img;
                            currentFileId = `video_${currentVideoId}_frame_${frameNumber}`;
                            
                            // Clear any existing selections
                            clearSelection();
                            
                            // Display in original canvas
                            displayImage(img);
                            
                            // Enable all controls for this frame
                            document.getElementById('segmentBtn').disabled = false;
                            document.getElementById('extractTextBtn').disabled = false;
                            document.getElementById('depthBtn').disabled = false;
                            
                            // Show instructions for the current mode
                            showInstructions();
                            
                            // Update the image container title to show it's a video frame
                            updateImageContainerTitle(`Video Frame ${frameNumber + 1}`);
                        };
                        img.src = data.frame_data;
                        
                        // Update timestamp
                        const timestamp = formatTimestamp(frame.timestamp);
                        document.getElementById('frameTimestamp').textContent = timestamp;
                    } else {
                        showError('Failed to load frame: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error loading frame:', error);
                    showError('Failed to load frame');
                });
        }

        function updateFrameLabels() {
            document.getElementById('currentFrameLabel').textContent = `Frame ${currentFrameNumber + 1}`;
            document.getElementById('totalFramesLabel').textContent = `of ${videoFrames.length}`;
        }

        function formatTimestamp(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function togglePlayPause() {
            const playPauseBtn = document.getElementById('playPauseBtn');
            
            if (isPlaying) {
                // Pause
                clearInterval(playInterval);
                isPlaying = false;
                playPauseBtn.textContent = '▶️';
            } else {
                // Play
                isPlaying = true;
                playPauseBtn.textContent = '⏸️';
                
                playInterval = setInterval(() => {
                    if (currentFrameNumber < videoFrames.length - 1) {
                        loadVideoFrame(currentFrameNumber + 1);
                } else {
                        // End of video
                        togglePlayPause();
                    }
                }, 1000 / videoMetadata.fps); // Play at video FPS
            }
        }

        function segmentVideoFrame() {
            if (!currentVideoId) {
                showError('No video loaded');
                return;
            }
            
            if (!currentImage) {
                showError('No frame loaded');
                return;
            }
            
            showLoading(true);
            
            // Determine prompt type based on current selection mode
            let prompt_type = 'grid';
            let prompts = [];
            
            if (selectionMode === 'points' && points.length > 0) {
                prompt_type = 'points';
                // Scale point coordinates to original image dimensions
                const originalWidth = currentImage.width;
                const originalHeight = currentImage.height;
                const canvasWidth = originalCanvas.width;
                const canvasHeight = originalCanvas.height;
                
                const scaleX = originalWidth / canvasWidth;
                const scaleY = originalHeight / canvasHeight;
                
                prompts = points.map(point => ({
                    x: Math.round(point.x * scaleX),
                    y: Math.round(point.y * scaleY),
                    is_positive: point.isPositive
                }));
            } else if (selectionMode === 'bbox' && bbox) {
                prompt_type = 'bbox';
                // Scale bbox coordinates to original image dimensions
                const originalWidth = currentImage.width;
                const originalHeight = currentImage.height;
                const canvasWidth = originalCanvas.width;
                const canvasHeight = originalCanvas.height;
                
                const scaleX = originalWidth / canvasWidth;
                const scaleY = originalHeight / canvasHeight;
                
                prompts = [{
                    x1: Math.round(bbox.x1 * scaleX),
                    y1: Math.round(bbox.y1 * scaleY),
                    x2: Math.round(bbox.x2 * scaleX),
                    y2: Math.round(bbox.y2 * scaleY)
                }];
            }
            
            fetch('/segment_video_frame', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: currentVideoId,
                    frame_number: currentFrameNumber,
                    prompt_type: prompt_type,
                    prompts: prompts
                })
            })
            .then(response => response.json())
            .then(data => {
                showLoading(false);
                if (data.success) {
                    // Display result (labels are already overlaid on the image)
                    displayResult(data.segmented_image);
                } else {
                    showError(data.error);
                }
            })
            .catch(error => {
                showLoading(false);
                console.error('Error:', error);
                showError('Segmentation failed');
            });
        }

        function showDownloadButton() {
            const downloadSection = document.getElementById('downloadSection');
            downloadSection.style.display = 'block';
        }


        function downloadPSDs() {
            if (!currentFileId) {
                showError('No image uploaded');
                return;
            }

            // Show loading state
            const downloadBtn = document.getElementById('downloadBtn');
            const originalText = downloadBtn.innerHTML;
            downloadBtn.innerHTML = '⏳ Creating PSD files...';
            downloadBtn.disabled = true;

            // Create download link
            const downloadUrl = `/download_psds/${currentFileId}`;
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = `masks_${currentFileId}.zip`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Reset button state
            setTimeout(() => {
                downloadBtn.innerHTML = originalText;
                downloadBtn.disabled = false;
            }, 2000);
        }

        function extractText() {
            if (!currentFileId) {
                showError('No image uploaded');
                return;
            }

            // Show loading state
            const extractBtn = document.getElementById('extractTextBtn');
            const originalText = extractBtn.innerHTML;
            extractBtn.innerHTML = '⏳ Extracting text...';
            extractBtn.disabled = true;

            // Hide previous text results
            document.getElementById('textResult').style.display = 'none';

            fetch(`/extract_text/${currentFileId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                extractBtn.innerHTML = originalText;
                extractBtn.disabled = false;

                if (data.success) {
                    displayTextResult(data);
                } else {
                    showError(data.error || 'Text extraction failed');
                }
            })
            .catch(error => {
                extractBtn.innerHTML = originalText;
                extractBtn.disabled = false;
                showError('Text extraction failed: ' + error.message);
            });
        }

        function displayTextResult(data) {
            const textResult = document.getElementById('textResult');
            const confidence = document.getElementById('confidence');
            const wordCount = document.getElementById('wordCount');
            const totalWords = document.getElementById('totalWords');
            const threshold = document.getElementById('threshold');
            const textDisplay = document.getElementById('textDisplay');
            const annotatedImageContainer = document.getElementById('annotatedImageContainer');
            const annotatedImage = document.getElementById('annotatedImage');
            const fontAnalysisContainer = document.getElementById('fontAnalysisContainer');
            const fontAnalysisContent = document.getElementById('fontAnalysisContent');
            const letterMasksContainer = document.getElementById('letterMasksContainer');
            const letterCount = document.getElementById('letterCount');

            // Update all info fields
            confidence.textContent = `Confidence: ${data.confidence}`;
            wordCount.textContent = `High-Confidence Words: ${data.word_count}`;
            totalWords.textContent = `Total Words Found: ${data.total_words_found}`;
            threshold.textContent = `Threshold: ${data.high_confidence_threshold}`;

            // Update text display
            textDisplay.textContent = data.text;

            // Show annotated image if available
            if (data.annotated_image) {
                annotatedImage.src = data.annotated_image;
                annotatedImageContainer.style.display = 'block';
            } else {
                annotatedImageContainer.style.display = 'none';
            }

            // Show font analysis if available
            if (data.font_analysis && data.font_analysis.length > 0) {
                displayFontAnalysis(data.font_analysis, fontAnalysisContent);
                fontAnalysisContainer.style.display = 'block';
            } else {
                fontAnalysisContainer.style.display = 'none';
            }

            // Show letter processing if available
            if (data.letter_count && data.letter_count > 0) {
                letterCount.textContent = `Letters Detected: ${data.letter_count}`;
                letterMasksContainer.style.display = 'block';
                
                // Store letter data for toggle function
                window.letterData = {
                    mask: data.letter_mask_visualization,
                    removed: data.letter_removed_image,
                    original: data.annotated_image
                };
                
                // Set default view to letter masks
                document.getElementById('letterImage').src = data.letter_mask_visualization;
            } else {
                letterMasksContainer.style.display = 'none';
            }

            // Show the result
            textResult.style.display = 'block';
        }
        
        function displayFontAnalysis(fontAnalysis, container) {
            let html = '';
            
            fontAnalysis.forEach(font => {
                const sizes = Array.isArray(font.sizes) ? font.sizes.join(', ') : font.sizes;
                const sampleWords = font.sample_words.join(', ');
                
                html += `
                    <div class="font-item">
                        <div class="font-header">
                            <strong>${font.name}</strong>
                            <span class="font-count">${font.count} words</span>
                        </div>
                        <div class="font-details">
                            <span class="font-sizes">Sizes: ${sizes}</span>
                            <span class="font-samples">Samples: ${sampleWords}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function toggleLetterView(viewType) {
            if (!window.letterData) return;
            
            const letterImage = document.getElementById('letterImage');
            const buttons = document.querySelectorAll('.letter-controls .btn');
            
            // Remove active class from all buttons
            buttons.forEach(btn => btn.classList.remove('btn-active'));
            
            // Add active class to clicked button
            event.target.classList.add('btn-active');
            
            // Update image based on view type
            switch(viewType) {
                case 'mask':
                    letterImage.src = window.letterData.mask;
                    break;
                case 'removed':
                    letterImage.src = window.letterData.removed;
                    break;
                case 'original':
                    letterImage.src = window.letterData.original;
                    break;
            }
        }

        function copyText() {
            const textDisplay = document.getElementById('textDisplay');
            const text = textDisplay.textContent;
            
            if (text && text !== 'No text found in the image.') {
                navigator.clipboard.writeText(text).then(() => {
                    // Show temporary success message
                    const copyBtn = event.target;
                    const originalText = copyBtn.innerHTML;
                    copyBtn.innerHTML = '✅ Copied!';
                    copyBtn.style.background = '#28a745';
                    
                    setTimeout(() => {
                        copyBtn.innerHTML = originalText;
                        copyBtn.style.background = '';
                    }, 2000);
                }).catch(() => {
                    showError('Failed to copy text to clipboard');
                });
            }
        }
        // Depth estimation
const depthCanvas = document.getElementById('depthCanvas');
const depthCtx = depthCanvas.getContext('2d');

        function displayDepth(base64Image) {
            const img = new Image();
            img.onload = function() {
                depthCanvas.width = resultCanvas.width;
                depthCanvas.height = resultCanvas.height;
                depthCtx.clearRect(0, 0, depthCanvas.width, depthCanvas.height);
                depthCtx.drawImage(img, 0, 0, depthCanvas.width, depthCanvas.height);
            };
            img.src = base64Image;
        }

        // Coordinate window functionality
        let currentCoordinates = null;

        function showCoordinateWindow() {
            if (currentCoordinates && currentCoordinates.length > 0) {
                displayCoordinates(currentCoordinates);
                document.getElementById('coordinateWindow').style.display = 'block';
            } else {
                showError('No coordinate data available. Please run segmentation first.');
            }
        }

        function closeCoordinateWindow() {
            document.getElementById('coordinateWindow').style.display = 'none';
        }

        function displayCoordinates(coordinates) {
            const coordinateList = document.getElementById('coordinateList');
            coordinateList.innerHTML = '';

            coordinates.forEach((item, index) => {
                const coordItem = document.createElement('div');
                coordItem.className = 'coordinate-item';
                
                const coords = item.coordinates || {};
                
                coordItem.innerHTML = `
                    <div class="coordinate-item-header">
                        <span class="coordinate-label">${item.label || 'Unknown'}</span>
                        <span class="coordinate-confidence">${Math.round((item.confidence || 0) * 100)}%</span>
                    </div>
                    <div class="coordinate-details">
                        <div class="coordinate-detail">
                            <span class="coordinate-detail-label">X (relative):</span>
                            <span class="coordinate-detail-value">${coords.relative_x || 0}</span>
                        </div>
                        <div class="coordinate-detail">
                            <span class="coordinate-detail-label">Y (relative):</span>
                            <span class="coordinate-detail-value">${coords.relative_y || 0}</span>
                        </div>
                        <div class="coordinate-detail">
                            <span class="coordinate-detail-label">Z (depth):</span>
                            <span class="coordinate-detail-value depth-value">
                                <span class="depth-indicator" style="background-color: ${coords.depth_color || '#808080'};"></span>
                                ${coords.relative_z || 0}
                            </span>
                        </div>
                        <div class="coordinate-detail">
                            <span class="coordinate-detail-label">Center X:</span>
                            <span class="coordinate-detail-value">${coords.center_x || 0}</span>
                        </div>
                        <div class="coordinate-detail">
                            <span class="coordinate-detail-label">Center Y:</span>
                            <span class="coordinate-detail-value">${coords.center_y || 0}</span>
                        </div>
                        <div class="coordinate-detail">
                            <span class="coordinate-detail-label">Mask #:</span>
                            <span class="coordinate-detail-value">${index + 1}</span>
                        </div>
                    </div>
                `;
                
                coordinateList.appendChild(coordItem);
            });
        }

        function copyCoordinates() {
            if (currentCoordinates) {
                const jsonString = JSON.stringify(currentCoordinates, null, 2);
                navigator.clipboard.writeText(jsonString).then(() => {
                    showSuccess('Coordinates copied to clipboard!');
                }).catch(() => {
                    showError('Failed to copy coordinates to clipboard');
                });
            }
        }

        function exportCoordinates() {
            if (currentCoordinates) {
                // Convert to CSV format
                let csv = 'Label,Confidence,Relative_X,Relative_Y,Relative_Z,Center_X,Center_Y,Mask_Index\n';
                
                currentCoordinates.forEach((item, index) => {
                    const coords = item.coordinates || {};
                    csv += `${item.label || 'Unknown'},${item.confidence || 0},${coords.relative_x || 0},${coords.relative_y || 0},${coords.relative_z || 0},${coords.center_x || 0},${coords.center_y || 0},${index + 1}\n`;
                });
                
                // Create and download CSV file
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'object_coordinates.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showSuccess('Coordinates exported to CSV!');
            }
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.content').insertBefore(successDiv, document.querySelector('.upload-section'));
            
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

    </script>
</body>
</html> 